# prueba-tecnica-doonamis
Prueba técnica Flutter

En mi experiencia laboral, he trabajado extensivamente con Provider en proyectos de Flutter y he logrado familiarizarme con su sintaxis y funcionamiento. Esto me permite ser más eficiente y productivo al utilizar una herramienta con la que ya estoy cómodo.
Además, aunque Riverpod ofrece algunas funcionalidades adicionales que pueden ser útiles en proyectos más grandes y complejos, en este caso particular, el uso de Provider es suficiente y cumple con los requisitos especificados.
También es importante tener en cuenta que al incluir Riverpod en un proyecto, se agregan dependencias adicionales que podrían aumentar el tiempo de construcción y potencialmente introducir problemas de compatibilidad. Al utilizar Provider, se reduce el número de dependencias y se simplifica el proceso de desarrollo.
En resumen, el uso de Provider en lugar de Riverpod se justifica por mi experiencia previa con esta herramienta, su capacidad para cumplir con los requisitos de la prueba, y la reducción de complejidad en el proceso de desarrollo.

En mi proyecto, he estructurado el código en varias carpetas que siguen una separación de responsabilidades y cumplen con los principios de diseño SOLID.
En particular, la carpeta 'api' se utiliza para almacenar las clases y funciones relacionadas con la comunicación con servicios externos, la carpeta 'pages' contiene las vistas principales de la aplicación, la carpeta 'global' almacena los estados globales que deben ser compartidos entre diferentes vistas, la carpeta 'l10n' se utiliza para almacenar los archivos de traducción de la aplicación, la carpeta 'provider' contiene los archivos que proporcionan la lógica de la aplicación, la carpeta 'widgets' almacena los widgets reutilizables, la carpeta 'utils' se utiliza para almacenar clases y funciones de utilidad, y finalmente, la carpeta 'classes' se utiliza para almacenar clases y estructuras de datos personalizadas.
Aunque esta estructura no sigue estrictamente el patrón MVVM, se puede decir que cumple con los principios generales de la arquitectura en términos de separación de responsabilidades y cohesión de los módulos. Además, esta estructura se adapta bien a proyectos de tamaño mediano a grande, y permite un fácil mantenimiento y extensibilidad

Aunque considero que la funcionalidad de modo offline es importante y útil, desafortunadamente, debido a la limitación de tiempo y al volumen de trabajo que he tenido estos días, no pude implementarla.
En este caso, Floor se podría haber utilizado para guardar los datos obtenidos de la API en la memoria del dispositivo, y luego se podrían haber recuperado de manera rápida y eficiente cuando el usuario volviera a utilizar la aplicación sin conexión.
Además, también se podría haber utilizado una lógica de almacenamiento en caché para almacenar los datos de la API más recientes y actualizarlos en segundo plano cuando la aplicación volviera a tener conexión a Internet. Esto permitiría que los usuarios tuvieran acceso a los datos más recientes incluso cuando no tienen conexión a Internet, lo que mejoraría la experiencia de usuario en general.

Si bien no he logrado realizar todos los puntos obligatorios, espero haber dado lo mejor de mí en las tareas realizadas y demostrarles que soy capaz de trabajar con solidez y consistencia.
Gracias por su tiempo y consideración, y espero tener la oportunidad de colaborar con ustedes en el futuro.
